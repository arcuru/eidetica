name: Container

on:
  # Trigger after Nix workflow completes on main branch
  workflow_run:
    workflows: ["Nix"]
    types: [completed]
    branches: ["main"]
  # Also trigger on releases
  release:
    types: [published]

env:
  REGISTRY_GHCR: ghcr.io
  REGISTRY_DOCKER: docker.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ${{ matrix.runner }}
    # Only run if Nix workflow succeeded (or if triggered by release/dispatch)
    if: |
      github.repository_owner == 'arcuru' &&
      (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success')
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
            platform: amd64
          - runner: ubuntu-24.04-arm
            platform: arm64
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@c5a866b6ab867e88becbed4467b93592bce69f8a # v21

      - name: Magic Nix Cache
        uses: DeterminateSystems/magic-nix-cache-action@565684385bcd71bad329742eefe8d12f2e765b39 # v13

      - name: Build container image with Nix
        run: nix build .#eidetica-image

      - name: Log in to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY_GHCR }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Load and push Nix base image
        id: nix-image
        run: |
          # Load image and capture the name
          LOADED=$(docker load < ./result)
          # Extract image name from "Loaded image: name:tag"
          NIX_IMAGE=$(echo "$LOADED" | grep -oP 'Loaded image: \K.*')
          echo "Loaded Nix image: ${NIX_IMAGE}"

          # Push base image to GHCR (buildx needs it accessible from registry)
          BASE_TAG="nix-base-${{ matrix.platform }}"
          docker tag "${NIX_IMAGE}" "${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${BASE_TAG}"
          docker push "${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${BASE_TAG}"
          echo "base_image=${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${BASE_TAG}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Determine tags
        id: tags
        run: |
          TAGS=""
          # Dev tag for main branch
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            TAGS="dev-${{ matrix.platform }}"
          fi
          # Release tags
          if [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
            VERSION="${VERSION#v}"  # Remove 'v' prefix
            TAGS="${VERSION}-${{ matrix.platform }}"
            # Add major.minor tag
            MINOR="${VERSION%.*}"
            TAGS="${TAGS} ${MINOR}-${{ matrix.platform }}"
            # Add major tag (skip for v0.x)
            MAJOR="${MINOR%.*}"
            if [[ "$MAJOR" != "0" ]]; then
              TAGS="${TAGS} ${MAJOR}-${{ matrix.platform }}"
            fi
          fi
          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"

      - name: Create attestation wrapper Dockerfile
        run: |
          # Create a minimal Dockerfile that uses the pushed Nix base image
          # This allows buildx to add SBOM and provenance attestations
          echo "FROM ${{ steps.nix-image.outputs.base_image }}" > Dockerfile.attestation

      - name: Build and push with attestations
        run: |
          for TAG in ${{ steps.tags.outputs.tags }}; do
            # Build with buildx to add SBOM and provenance attestations
            # Push to both registries with attestations embedded
            docker buildx build \
              --file Dockerfile.attestation \
              --sbom=true \
              --provenance=mode=max \
              --tag "${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${TAG}" \
              --tag "${{ env.IMAGE_NAME }}:${TAG}" \
              --push \
              .
          done

  manifest:
    runs-on: ubuntu-latest
    needs: build
    if: github.repository_owner == 'arcuru'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Log in to GHCR
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ${{ env.REGISTRY_GHCR }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Determine manifest tags
        id: tags
        run: |
          TAGS=""
          # Dev tag for workflow_run (after Nix completes on main)
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            TAGS="dev"
          fi
          # Release tags
          if [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
            VERSION="${VERSION#v}"
            TAGS="${VERSION}"
            MINOR="${VERSION%.*}"
            TAGS="${TAGS} ${MINOR}"
            MAJOR="${MINOR%.*}"
            if [[ "$MAJOR" != "0" ]]; then
              TAGS="${TAGS} ${MAJOR}"
            fi
            # Latest tag for non-prerelease
            if [[ "${{ github.event.release.prerelease }}" != "true" ]]; then
              TAGS="${TAGS} latest"
            fi
          fi
          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"

      - name: Create and push manifests
        run: |
          for TAG in ${{ steps.tags.outputs.tags }}; do
            # Create multi-arch manifest for GHCR using imagetools (handles manifest lists with attestations)
            docker buildx imagetools create \
              --tag "${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${TAG}" \
              "${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${TAG}-amd64" \
              "${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${TAG}-arm64"

            # Create multi-arch manifest for Docker Hub
            docker buildx imagetools create \
              --tag "${{ env.IMAGE_NAME }}:${TAG}" \
              "${{ env.IMAGE_NAME }}:${TAG}-amd64" \
              "${{ env.IMAGE_NAME }}:${TAG}-arm64"
          done

      - name: Cleanup intermediate images
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Delete the nix-base-* intermediate images from GHCR
          for PLATFORM in amd64 arm64; do
            echo "Deleting nix-base-${PLATFORM}..."
            gh api --method DELETE "/users/${{ github.repository_owner }}/packages/container/eidetica/versions/$(
              gh api "/users/${{ github.repository_owner }}/packages/container/eidetica/versions" \
                --jq ".[] | select(.metadata.container.tags[] == \"nix-base-${PLATFORM}\") | .id"
            )" 2>/dev/null || echo "Could not delete nix-base-${PLATFORM} (may not exist or lack permissions)"
          done
